//Tyler Bieker
//CS 261 Lab 6
//08/01/2016

//table.cpp

#include "table.h"

void duplicate(node * root, node *& newRoot){
    //recursively create a copy of the source tree with root. newRoot is the root of the
    //destination tree.

    node * src = root;
    node * dest = newRoot;
    newRoot = copy(src, dest);
    return;
}

node * copy(node * src, node * dest){
    if(src == nullptr){
        dest = nullptr;
        return dest;
    }else{
        dest = new node;
        dest->data = src->data;
        dest->left = copy(src->left, dest->left);
        dest->right = copy(src->right, dest->right);
        return dest;
    }
}

void remove(node *& root, int target){
    //recursively remove the target from the tree
    root = rRemove(root, target);
    return;
}

node * rRemove(node * root, int target){
    if(root == nullptr){
        return root;
    }
    else if(root->data == target){
        if(root->left == nullptr && root->right == nullptr){
            //root is a leaf
            delete root;
            root = nullptr;
            return root;
        }
        else if(root->left == nullptr && root->right != nullptr){
            //root has right branch but null left branch
            node * temp;
            temp = root;
            root = root->right;
            delete temp;
            return root;
        }
        else if(root->left != nullptr && root->right == nullptr){
            //root has left branch but null right branch
            node * temp;
            temp = root;
            root = root->left;
            delete temp;
            return root;
        }
        else{
            //root has two branches
            node * temp;
            temp = getNode(root->right, root);
            temp->right = root->right;
            temp->left = root->left;
            delete root;
            root = temp;
            return temp;
        }
    }
    else if(target < root->data){
        //target is less, search left branches
        root->left = rRemove(root->left, target);
        return root;
    }
    else if(target > root->data){
        //target is greater, search right branches
        root->right = rRemove(root->right, target);
        return root;
    }
}

node * getNode(node * root, node * prev){
    if(root->left == nullptr && root->right == nullptr){
        prev->left = nullptr;
        return root;
    }else{
        return getNode(root->left, root);
    }
}
Welcome to the Proficiency Demo!

Inorder traversal: 76  87  94  100  100  105  106  132  160  211  229  

Level 1: 211
Level 2: 160 and 229
Level 3: 106
Level 4: 105 and 132
Level 5: 100
Level 6: 94 and 100
Level 7: 87
Level 8: 76


This tree contains 11 items 

After duplicating root: 
**************************************************************

The resulting tree after your function ran is: 
Inorder traversal: 76  87  94  100  100  105  106  132  160  211  229  

Level 1: 211
Level 2: 160 and 229
Level 3: 106
Level 4: 105 and 132
Level 5: 100
Level 6: 94 and 100
Level 7: 87
Level 8: 76


This tree contains 11 items 
**************************************************************
Enter target to remove: 
After removing: 105
**************************************************************

The resulting tree after your function ran is: 
Inorder traversal: 76  87  94  100  100  106  132  160  211  229  

Level 1: 211
Level 2: 160 and 229
Level 3: 106
Level 4: 100 and 132
Level 5: 94 and 100
Level 6: 87
Level 7: 76


This tree contains 10 items 
**************************************************************

The resulting tree after your function ran is: 
Inorder traversal: 76  87  94  100  100  105  106  132  160  211  229  

Level 1: 211
Level 2: 160 and 229
Level 3: 106
Level 4: 105 and 132
Level 5: 100
Level 6: 94 and 100
Level 7: 87
Level 8: 76


This tree contains 11 items 
